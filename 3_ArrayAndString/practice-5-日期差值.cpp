
/*
     问题: 给定两个日期, 求两个日期之间的天数. 如果两个日期是连续的, 则规定他们之间的天数为两天.
     输入格式: 有多组数据, 每组数据有两行, 分别表示两个日期, 形式为 YYYYMMDD.
     输出格式: 每组数据输出一行, 即日期差值.
     样例输入
      20130101
      20130105
     样例输出
       5
*/
/*
    思路: 假设第一个日期比第二个日期早(否则交换即可), 让第一个日期不断地 +1, 直到两日期相等, 即可统计出答案.
          如果当加了一天之后 d 等于当前月份的天数加1, 则另月份 m 加 1, 同时置 d 为 1 (即日期变为下个月1号);
          如果月份 m 变成了 13, 则另年份 y 加 1, 同时置月份 m 为 1月 (即把日期变为下一年1月).
          可以采用一个二维数组存储每个月的天数, 第一维表示平年, 第二维表示闰年, 如 month[2][0]
          表示平年 2 月份天数, month[2][1] 表示闰年 2 月份天数.
*/

#include <cstdio>

int month[13][2] = {
    {0, 0}, // month[0]是为了占位置, 以便让月份从1开始
    {31, 31}, 
    {28, 29}, 
    {31, 31}, 
    {30, 30}, 
    {31, 31}, 
    {30, 30}, 
    {31, 31}, 
    {31, 31}, 
    {30, 30}, 
    {31, 31}, 
    {30, 30}, 
    {31, 31}
};

int isLeap(int year) { // 判断是否是闰年
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

int main(void) {

    int time1, y1, m1, d1;
    int time2, y2, m2, d2;
    while(scanf("%d%d", &time1, &time2) != EOF) {
        if(time1 > time2) { // 确保第一个日期早于第二个日期, 便于计算
            int t = time1;
            time1 = time2;
            time2 = t;
        }
        y1 = time1 / 10000;
        m1 = time1 % 10000 / 100;
        d1 = time1 % 100;
        y2 = time2 / 10000;
        m2 = time2 % 10000 / 100;
        d2 = time2 % 100;
        int days = 1;
        while(!(y1 == y2 && m1 == m2 && d1 == d2)) {
            d1++;
            if(d1 == month[m1][isLeap(y1)] + 1) { // 变为下个月1号
                m1++;
                d1 = 1;
            }
            if(m1 == 13) { // 变为下一年1月
                y1++;
                m1 = 1;
            }
            days++;
        }
        printf("%d\n", days);
    }

    return 0;
}
