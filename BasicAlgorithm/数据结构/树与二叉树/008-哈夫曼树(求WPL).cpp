/*    
    哈夫曼树(最优二叉树)
        已知 n 个数, 寻找一棵树, 使得树的所有叶子结点的权值恰好为这 n 个数, 并且使得这棵树的带权路径长度最小.
        这棵带权路径长度最小的树被称为哈夫曼树. 对同一组叶子结点来说, 哈夫曼树不唯一, 但最小带权路径长度一定唯一.
        叶子结点的带权路径长度 = 叶子结点权值 * 路径长度.
        树的带权路径长度(WPL) = 所有叶子结点的带权路径长度之和 = 所有非叶子结点的权值之和.
    哈夫曼树的性质
        1. 哈夫曼树中不存在度为 1 的结点;
        2. 哈夫曼树的总结点数 = 2n-1 (n为叶子结点个数);
        3. 哈夫曼树中权值越大的结点越接近根结点.
    哈夫曼树的构造
        1. 初始状态下有 n 个结点, 结点的权值就是给定的 n 个数, 将它们视为 n 棵只有一个结点的树;
        2. 合并其中根结点权值最小的两棵树, 生成两棵树根结点的父结点, 权值为这两个根结点的权值之和, 这样树的数量就减少了一个;
        3. 重复步骤2, 直到只剩下一棵树为止, 这棵树就是哈夫曼树.
*/

#include <cstdio>
#include <queue>
using namespace std;

/*
    更多时候, 我们不需要真的去创建一棵哈夫曼树, 而是要得到哈夫曼树的带权路径长度, 因此我们掌握哈夫曼树的构建思想即可,
    也就是反复选择两个最小的元素, 合并, 直到只剩下一个元素. 一般可以用优先队列(小顶堆)来执行这种策略: 将给定的 n 个数
    压入优先队列, 之后每次从优先队列顶部取出两个最小的数, 将它们相加并将结果重新压入优先队列, 外部定义一个变量ans, 将相加的
    结果累加, 重复此过程直到优先队列中只剩下一个数, 此时的 ans 就是最小带权路径长度.
*/

struct cmp {
    bool operator () (int a, int b) {
        return a > b;
    }
};

// 获取给定n个数的最小带权路径长度
int get_min_wpl(int init[], int n) {
    priority_queue<int, vector<int>, cmp> q;
    for(int i = 0; i < n; i++) { // 将初始数据压入优先队列
        q.push(init[i]);
    }

    int ans = 0;
    while(q.size() > 1) { // 只要优先队列中有多于1个元素
        int x = q.top();
        q.pop();
        int y = q.top();
        q.pop();
        q.push(x + y); // 取出队首两个最小元素, 求和后压入优先队列
        ans += (x + y); // 累计求和结果(WPL=所有非叶子结点的权值之和)
    }

    return ans;
}

int main(void) {

    int init[] = { 1,2,2,3,6 };
    printf("WPL = %d\n", get_min_wpl(init, 5));

    return 0;
}
