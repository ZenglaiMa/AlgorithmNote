
// 题目: 实现一个经典猜数字游戏. 给定答案序列和用户猜的序列(数字1~9), 统计有多少个数字位置正确(A), 
//       有多少个数字在两序列中都出现过但位置不对(B). 输入包含多组数据, 每组输入第一行为
//       序列长度 n(n<1000), 第二行是答案序列, 接下来是若干猜测序列, 猜测序列全0时该组结束, n=0时输入结束.
/*
   样例输入:
   4
   1 3 5 5
   1 1 2 3
   4 3 3 5
   6 5 5 1
   6 1 3 5
   1 3 5 5
   0 0 0 0
   10
   1 2 2 2 4 5 6 6 6 9
   1 2 3 4 5 6 7 8 9 1
   1 1 2 2 3 3 4 4 5 5
   1 2 1 3 1 5 1 6 1 9
   1 2 2 5 5 5 6 6 6 7
   0 0 0 0 0 0 0 0 0 0
   0
   
   样例输出:
   Game 1:
      (1,1)
      (2,0)
      (1,2)
      (1,2)
      (4,0)
   Game 2:
      (2,4)
      (3,2)
      (5,0)
      (7,0)
*/

/*
  思路: 题意可理解成, 在两个序列"都包含"的数字(可以理解成两个序列的交集)中, 有几个位置正确, 几个位置不正确.
        对于A, 直接统计猜测序列和答案序列对应位置相等的数字的个数即可. 为了求B, 对于每个数字1~9, 分别统计其在
        答案序列和猜测序列中出现的次数, 记为c1, c2, 则 t=min(c1, c2)表示某数字在两序列中"都出现过"t次,
        即两序列中"都包含" t 个该数字, 其减去位置正确的个数, 剩下的就是位置不正确的个数.
*/

#include <stdio.h>

int a[1010];
int b[1010];

int main(void) {

    int n, kase = 0;
    while(scanf("%d", &n) == 1 && n) { // n=0时输入结束
        printf("Game %d:\n", ++kase);
        for(int i = 0; i < n; i++) { // 输入答案序列
            scanf("%d", &a[i]);
        }
        while(1) { // 处理猜测序列
            int A = 0, B = 0;
            for(int i = 0; i < n; i++) {
                scanf("%d", &b[i]);
                if(b[i] == a[i])
                    A++;
            }
            if(b[0] == 0) // 正常的猜测序列不会出现0, 所以只需判断b[0]是否为零即可
                break;
            for(int i = 1; i <= 9; i++) {
                int c1 = 0, c2 = 0;
                for(int j = 0; j < n; j++) { // 统计数字 i 在两序列中出现的次数
                    if(a[j] == i)
                        c1++;
                    if(b[j] == i)
                        c2++;
                }
                if(c1 < c2)
                    B += c1;
                else
                    B += c2;
            }
            printf("   (%d,%d)\n", A, B - A);
        }
    }

    return 0;
}
